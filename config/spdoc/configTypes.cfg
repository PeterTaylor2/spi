/* -*-c++-*- */

/*

    Sartorial Programming Interface (SPI) code generators
    Copyright (C) 2012-2023 Sartorial Programming Ltd.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

*/
/**
 * configuration file for structures containing the documentation of a service
 *
 * this is created by the c++ generator and is designed to be sufficient
 * for all other generators
 *
 * implementation details of classes and functions are omitted, but we
 * keep description, all constructs etc.
 *
 * for each generator, there should be something that can generate the
 * code (or documentation) for each data type detected in the service
 */

%module configTypes;

#include <sstream>

/**
 * Defines a data type.
 *
 * This involves things such as the internal name, plus information on how
 * the type is declared and passed as an input to a function call etc.
 */
struct DataType
{
    // currently no point in describing each field since the description
    // does not appear in the generated header files and there is no user
    // guide for spdoc
    string name;
    bool passByReference;
    string refTypeName;
    string valueTypeName;
    PublicType publicType;
    bool noDoc;
    string nsService = "";
    bool objectAsValue = False canHide = True;

    /** Returns the value type (includes the namespace) */
    extern string ValueType()
    {
        if (self->nsService.empty())
            return self->valueTypeName;

        std::ostringstream oss;
        oss << self->nsService << "::" << self->valueTypeName;
        return oss.str();
    }

    /** Returns the reference type (includes the namespace) */
    extern string RefType()
    {
        if (self->nsService.empty())
            return self->refTypeName;

        std::ostringstream oss;
        if (self->valueTypeName == self->refTypeName)
        {
            oss << self->nsService << "::" << self->refTypeName;
        }
        else
        {
            // the assumption is that refTypeName = "const valueTypeName&"
            oss << "const " << self->nsService << "::" 
                << self->valueTypeName << "&";
        }
        return oss.str();
    }

};

/**
 * Defines an attribute which is an input to a function call or output
 * from a function call.
 */
struct Attribute noId=True
{
    // perhaps we should rename attribute as Arg
    string name;
    string[] description canHide = True;
    DataType dataType;
    int arrayDim = 0 canHide = True;
    bool isOptional = False canHide = True;
    Constant defaultValue? canHide=True;

    property bool isArray
    {
        return arrayDim > 0;
    }

    extern string encoding(bool isOutput = False, bool showDefault = False)
    {
        std::ostringstream oss;
        oss << self->dataType->name << " ";
        if (isOutput)
            oss << "&";
        oss << self->name;
        if (self->isOptional)
        {
            if (showDefault && self->defaultValue && self->arrayDim == 0)
            {
                const std::string& docString = self->defaultValue->docString();
                if (docString.empty())
                {
                    oss << "?";
                }
                else
                {
                    oss << " = " << docString;
                }
            }
            else
            {
                oss << "?";
            }
        }
        for (int i = 0; i < self->arrayDim; ++i)
            oss << "[]";
        return oss.str();
    }  
}
{
    SPI_PRE_CONDITION(arrayDim >= 0 && arrayDim <= 2);
}

/**
 * Defines an attribute of a class.
 */
struct ClassAttribute noId=True
{
    string name;
    string[] description canHide = True;
    DataType dataType;
    int arrayDim = 0 canHide=True;
    bool isOptional = False canHide=True;
    Constant defaultValue? canHide=True;
    bool accessible;
    string accessor;

    operator Attribute()
    {
        return Attribute::Make(name, description, dataType, arrayDim, isOptional, defaultValue);
    }

    property bool isArray
    {
        return arrayDim > 0;
    }

    extern string encoding(bool showDefault = false)
    {
        if (!self->accessible)
            return std::string();
        std::ostringstream oss;
        oss << self->dataType->name << " " << self->name;
        if (self->isOptional)
        {
            const std::string& docString = self->defaultValue->docString();
            if (docString.empty())
            {
                oss << "?";
            }
            else
            {
                oss << " = " << docString;
            }
        }
        for (int i = 0; i < self->arrayDim; ++i)
            oss << "[]";
        return oss.str();
    }
}
{
    SPI_PRE_CONDITION(arrayDim >= 0 && arrayDim <= 2);
}

/**
 * Defines a construct - this is something that is defined by a module
 * and can be either some sort of type definition or function.
 */
struct virtual Construct noId=True
{
    /**
     * Returns the type of the Construct - specific to each sub-class of
     * Construct.
     *
     * Inside the module we keep a list of constructs in the order that
     * they were defined, but we will often need to know what type of
     * Construct object we have in order to decide what to do with it!
     */
    virtual string getType() const;

    /**
     * Returns a short summary of the construct (disregarding description)
     *
     * If the construct is undocumented then this will be a zero size array
     */
    virtual string[] Summary(bool includeDescription = false) const;

public:
    virtual std::string getName() const = 0;
};

/**
 * Defines a simple type.
 */
struct SimpleType : Construct canPut=True
{
    string name;
    string[] description canHide = True;
    string typeName;
    bool noDoc = False canHide=True;

    /**
     * Returns "SIMPLE_TYPE"
     */
    extern string getType() const
    {
        return "SIMPLE_TYPE";
    }

    extern string[] Summary(bool includeDescription=false) const
    {
        std::vector<std::string> summary;
        if (!self->noDoc)
        {
            if (includeDescription)
            {
                for (auto const& item : self->description)
                    summary.push_back("# " + item);
            }
            std::ostringstream oss;
            oss << "typedef " << self->typeName << " " << self->name << ";";
            summary.push_back(oss.str());
        }
        return summary;
    }

public:
    std::string getName() const { return name; } 
};

/**
 * Defines a function.
 */
struct Function : Construct canPut=True
{
    string name;
    string[] description canHide = True;
    string[] returnTypeDescription canHide = True;
    DataType returnType;
    int returnArrayDim = 0 canHide=True;
    Attribute[] inputs canHide=True;
    Attribute[] outputs canHide=True;
    string[] excelOptions canHide=True;
    bool optionalReturnType = False canHide = True;

    /**
     * Does this Function return an object or not?
     */
    extern bool returnsObject() const
    {
        if (self->objectCount() > 0)
            return true;
        return false;
    }

    /**
     * What does the function return (as an attribute)
     */
    extern Attribute returns() const
    {
        return self->returns();
    }

    /**
     * How many objects does this function return?
     */
    extern int objectCount() const
    {
        if (self->returnType)
        {
            PublicType publicType = self->returnType->publicType;
            if (publicType == PublicType::CLASS ||
                publicType == PublicType::OBJECT ||
                publicType == PublicType::MAP)
            {
                if (self->returnType->objectAsValue)
                    return 0;
                return 1;
            }
            return 0;
        }
        int objectCount = 0;
        for (size_t i = 0; i < self->outputs.size(); ++i)
        {
            PublicType publicType = self->outputs[i]->dataType->publicType;
            if (publicType == PublicType::CLASS ||
                publicType == PublicType::OBJECT ||
                publicType == PublicType::MAP)
            {
                if (!self->outputs[i]->dataType->objectAsValue)
                    ++objectCount;
            }
        }
        return objectCount;
    }

    extern string[] Summary(bool includeDescription=false) const
    {
        std::vector<std::string> summary;
        if (includeDescription)
        {
            for (auto const& item : self->description)
                summary.push_back("# " + item);
        }

        std::ostringstream oss;
        if (self->returnType)
        {
            oss << self->returnType->name;
            for (int i = 0; i < self->returnArrayDim; ++i)
                oss << "[]";   
        }
        else
        {
            oss << "void";
        }
        oss << " " << self->name << "(";
        if (self->inputs.size() == 0 && self->outputs.size() == 0)
        {
            oss << ");";
            summary.push_back(oss.str());
        }
        else
        {
            summary.push_back(oss.str());
            std::vector<std::string> args;
            std::vector<std::vector<std::string>> argsDescription;
            for (size_t i = 0; i < self->inputs.size(); ++i)
            {
                args.push_back(self->inputs[i]->encoding(false, includeDescription));
                argsDescription.push_back(self->inputs[i]->description);
            }
            for (size_t i = 0; i < self->outputs.size(); ++i)
            {
                args.push_back(self->outputs[i]->encoding(true, includeDescription));
                argsDescription.push_back(self->outputs[i]->description);
            }
            size_t numArgs = args.size();
            for (size_t i = 0; i < numArgs; ++i)
            {
                std::ostringstream oss;
                oss << "    " << args[i];
                if ((i+1) == numArgs)
                {
                    oss << ");";
                }
                else
                {
                    oss << ",";
                }
                if (includeDescription)
                {
                    for (auto const& item : argsDescription[i])
                        summary.push_back("# " + item);
                }
                summary.push_back(oss.str());
            }
        }

        if (includeDescription)
        {
            for (auto const& item : self->returnTypeDescription)
                summary.push_back("# " + item);
        }

        return summary;
    }

    /**
     * Returns "FUNCTION"
     */
    extern string getType() const
    {
        return "FUNCTION";
    }

public:
    std::string getName() const { return name; } 
};

/**
 * Defines an enumerand.
 */
struct Enumerand noId=True
{
    string code;
    string[] strings canHide=True;
    string[] description canHide=True;
};

// this class is purely used for the user guides (or so we believe at present)
struct EnumConstructor noId = True
{
    PublicType constructorType;
    string[] description;
};

/**
 * Defines an enumerated type.
 */
struct Enum : Construct canPut=True
{
    string name;
    string[] description canHide=True;
    Enumerand[] enumerands;
    EnumConstructor[] constructors canHide = True;
    bool isBitmask = False canHide = True;

    /**
     * Returns "ENUM"
     */
    extern string getType() const
    {
        return "ENUM";
    }

    extern string[] Summary(bool includeDescription=false) const
    {
        std::vector<std::string> summary;

        if (includeDescription)
        {
            for (auto const& item : self->description)
                summary.push_back("# " + item);
        }
        size_t numEnumerands = self->enumerands.size();
        
        if (numEnumerands > 0)
        {
            std::ostringstream oss;
            oss << "enum ";
            if (self->isBitmask)
                oss << "bitmask ";
            oss << self->name;
            summary.push_back(oss.str());
            summary.push_back("{");
            for (size_t i = 0; i < numEnumerands; ++i)
            {
                std::ostringstream oss;
                if (includeDescription)
                {
                    for (auto const& item : self->enumerands[i]->description)
                        summary.push_back("# " + item);
                }
                oss << "    " << self->enumerands[i]->code;
                if ((i+1) < numEnumerands)
                    oss << ",";
                summary.push_back(oss.str());
            }
            summary.push_back("};");
        }
        else
        {
            std::ostringstream oss;
            oss << "enum " << self->name << ";";
            summary.push_back(oss.str());
        }

        return summary;
    }

public:
    std::string getName() const { return name; } 
};

/**
 * Defines a class method.
 */
struct ClassMethod noId=True
{
    Function function;
    bool isConst;
    bool isVirtual = False canHide=True;
    bool isStatic = False canHide=True;
    bool isImplementation = False canHide = True;
    string implements = "" canHide=True;

    extern string[] Summary(bool includeDescription=false) const
    {
        std::vector<std::string> summary;
        std::vector<std::string> funcSummary = self->function->Summary(includeDescription);

        size_t numLines = funcSummary.size();
        if (numLines == 0)
            return summary;
        summary.reserve(numLines);

        //if (self->isConst)
        //{
        //    std::string lastLine = spi_util::StringReplace(funcSummary[numLines-1], ";", " const;");
        //    funcSummary[numLines-1] = lastLine;
        //}
        size_t j = 0;
        for (j = 0; j < numLines; ++j)
        {
            if (funcSummary[j][0] == '#')
                summary.push_back("    " + funcSummary[j]);
            else
                break;
        }

        std::ostringstream oss;
        oss << "    ";
        if (self->isVirtual)
            oss << "virtual ";
        if (self->isStatic)
            oss << "static ";

        oss << funcSummary[j];
        summary.push_back(oss.str());

        for (size_t i = j+1; i < numLines; ++i)
        {
            std::string line = funcSummary[i];
            // there might be description of the return type after the ";" which ends the function
            if (self->isConst && line[0] != '#' && line[line.size() - 1] == ';')
            {
                line = line.substr(0, line.size() - 2) + " const;";
            }
            summary.push_back("    " + line);
        }

        return summary;
    }
};

/**
 * Defines a CoerceFrom constructor for creating a class by coercion
 * from a single input of some other type.
 */
struct CoerceFrom noId = True
{
    string[] description canHide = True;
    Attribute coerceFrom;

    extern string[] Summary(bool includeDescription=false) const
    {
        std::string encoding = self->coerceFrom->encoding(false, includeDescription);
        std::vector<std::string> summary;

        if (includeDescription)
        {
            for (auto const& item : self->description)
                summary.push_back("# " + item);
        }
        std::ostringstream oss;
        oss << "    static Coerce(" << encoding << ");";
        summary.push_back(oss.str());
        return summary;
    }
};
 
/**
 * Defines a CoerceTo operator for creating a class by coercion
 * to a class from an instance of another class.
 */
struct CoerceTo noId = True
{
    string[] description canHide = True;
    string className;
    DataType classType;

    extern string[] Summary(bool includeDescription=false) const
    {
        std::vector<std::string> summary;
        if (includeDescription)
        {
            for (auto const& item : self->description)
                summary.push_back("# " + item);
        }
        std::ostringstream oss;
        oss << "    operator " << self->className << "();";
        summary.push_back(oss.str());
        return summary;
    }
};

/**
 * Defines a class.
 */
struct Class : Construct canPut=True
{
    string name;
    string ns = "" canHide=True;
    string[] description canHide=True;
    // as currently stands we cannot forward declare
    // hence we cannot define the baseClassName as a Class
    string baseClassName = "" canHide=True;
    ClassAttribute[] attributes canHide=True;
    ClassAttribute[] properties canHide=True;
    ClassMethod[] methods canHide=True;
    CoerceFrom[] coerceFrom canHide=True;
    CoerceTo[] coerceTo canHide=True;
    bool isAbstract = False canHide=True;
    bool noMake = False canHide=True;
    string objectName;
    DataType dataType;
    bool isDelegate = False canHide=True;
    bool canPut = False canHide=True;
    bool hasDynamicAttributes = False canHide=True;
    bool asValue = False canHide=True;
    string constructor = "" canHide=True;

    extern string[] Summary(bool includeDescription=false) const
    {
        std::vector<std::string> summary;
        if (includeDescription)
        {
            for (auto const& item : self->description)
                summary.push_back("# " + item);
        }
        std::ostringstream oss;
        oss << "class " << self->name;
        if (!self->baseClassName.empty())
            oss << " : " << self->baseClassName;
        summary.push_back(oss.str());
        summary.push_back("{");

        bool started = false;
        for (size_t i = 0; i < self->attributes.size(); ++i)
        {
            std::ostringstream oss;
            std::string encoding = self->attributes[i]->encoding(includeDescription);
            if (!encoding.empty())
            {
                if (includeDescription)
                {
                    for (auto const& item : self->attributes[i]->description)
                        summary.push_back("# " + item);
                }
                oss << "    " << encoding << ";";
                summary.push_back(oss.str());
                started = true;
            }
        }
        for (size_t i = 0; i < self->properties.size(); ++i)
        {
            std::ostringstream oss;
            std::string encoding = self->properties[i]->encoding();
            if (!encoding.empty())
            {
                if (includeDescription)
                {
                    for (auto const& item : self->properties[i]->description)
                        summary.push_back("# " + item);
                }
                oss << "    property " << encoding << ";";
                summary.push_back(oss.str());
                started = true;
            }
        }
        for (size_t i = 0; i < self->methods.size(); ++i)
        {
            std::vector<std::string> mSummary = self->methods[i]->Summary(includeDescription);
            if (started)
                summary.push_back("");
            else
                started = true;
            for (size_t j = 0; j < mSummary.size(); ++j)
                summary.push_back(mSummary[j]);
        }
        for (size_t i = 0; i < self->coerceFrom.size(); ++i)
        {
            std::vector<std::string> cfSummary = self->coerceFrom[i]->Summary(includeDescription);
            if (started)
                summary.push_back("");
            else
                started = true;
            summary.insert(summary.end(), cfSummary.begin(), cfSummary.end());
        }
        for (size_t i = 0; i < self->coerceTo.size(); ++i)
        {
            std::vector<std::string> ctSummary = self->coerceTo[i]->Summary(includeDescription);
            if (started)
                summary.push_back("");
            else
                started = true;
            summary.insert(summary.end(), ctSummary.begin(), ctSummary.end());
        }
        summary.push_back("};");

        return summary;
    }


    /**
     * Returns "CLASS"
     */
    extern string getType() const
    {
        return "CLASS";
    }

    /**
     * Returns the object name. If objectName is defined, then that is the
     * object name. Otherwise name is the object name.
     */
    extern string ObjectName() const
    {
        if (self->objectName.empty())
            return self->name;
        return self->objectName;
    }

    extern string ServiceNamespace() const
    {
        if (!self->dataType)
            throw spi::RuntimeError("No data type for class %s",
                self->name.c_str());
        return self->dataType->nsService;
    }

public:
    std::string getName() const { return name; } 
};

/**
 * Defines a module.
 */
struct Module noId=True
{
    string name;
    string[] description canHide=True;
    string ns="" canHide=True;
    Construct[] constructs canHide=True;

    static string[] combineSummaries(Module[] modules, bool sort)
    {
        std::vector<std::string> summary;
        size_t numModules = modules.size();
        std::map<std::string, std::vector<std::string> > nameIndex;
        for (size_t i = 0; i < numModules; ++i)
        {
            ModuleConstSP m = modules[i];
            size_t numConstructs = m->constructs.size();
            for (size_t j = 0; j < numConstructs; ++j)
            {
                const ConstructConstSP& c = m->constructs[j];
                std::vector<std::string> cSummary = c->Summary();
                if (cSummary.size() > 0)
                {
                    if (sort)
                    {
                        nameIndex[c->getName()] = cSummary;
                    }
                    else
                    {
                        summary.push_back("");
                        summary.insert(summary.end(), cSummary.begin(), cSummary.end());
                    }
                }
            }
        }
        if (sort)
        {
            for (std::map<std::string, std::vector<std::string> >::const_iterator iter = nameIndex.begin();
                 iter != nameIndex.end(); ++iter)
            {
                summary.push_back("");
                summary.insert(summary.end(), iter->second.begin(), iter->second.end());
            }
        }
        return summary;
    }
};

/**
 * Defines a service.
 */
struct Service noId=True
{
    string name;
    string[] description canHide=True;
    string longName;
    string ns;
    string declSpec;
    string version;
    Module[] modules canHide=True;
    Class[] importedBaseClasses canHide=True;
    Enum[] importedEnums canHide=True;
    /** Indicates that this service is shared with a previously defined service.
        As a result we will not implement some of the common service functions for the add-ins. */
    bool sharedService = False canHide=True;

    extern Service CombineSharedServices(Service[] sharedServices) const
    {
        SPI_PRE_CONDITION(!self->sharedService);

        std::vector<std::string> description = self->description;
        std::vector<ModuleConstSP> modules = self->modules;
        for (const auto& sharedService : sharedServices)
        {
            SPI_PRE_CONDITION(sharedService->sharedService);
            SPI_PRE_CONDITION(sharedService->ns == self->ns);

            const auto& sharedDescription = sharedService->description;
            const auto& sharedModules = sharedService->modules;

            if (description.size() == 0)
            {
                description = sharedDescription;
            }
            else if (sharedDescription.size() > 0)
            {
                description.push_back(std::string());
                description.insert(
                    description.end(),
                    sharedDescription.begin(),
                    sharedDescription.end());
            }

            modules.insert(modules.end(), sharedModules.begin(), sharedModules.end());
        }

        return Service::Make(
            self->name,
            description,
            self->longName,
            self->ns,
            self->declSpec,
            self->version,
            modules,
            self->importedBaseClasses,
            self->importedEnums,
            false); // sharedService flag
    }

    extern string[] Summary(bool sort) const
    {
        std::vector<std::string> summary;
        size_t numModules = self->modules.size();
        std::ostringstream oss;
        oss << self->name << " namespace = " << self->ns << " version = " << self->version << ";";
        summary.push_back(oss.str());
        const std::vector<std::string>& moduleSummaries = Module::combineSummaries(self->modules, sort);
        summary.insert(summary.end(), moduleSummaries.begin(), moduleSummaries.end());
        return summary;
    }

    static string[] combineSummaries(Service[] services, bool sort)
    {
        SPI_PRE_CONDITION(services.size() > 0);

        size_t numServices = services.size();
        if (numServices == 1)
            return services[0]->Summary(sort);

        SPI_PRE_CONDITION(!services[0]->sharedService);

        std::vector<std::string> summary;
        std::ostringstream oss;
        oss << services[0]->name << " namespace = " << services[0]->ns << " version = " << services[0]->version << ";";
        summary.push_back(oss.str());

        std::vector<ModuleConstSP> modules = services[0]->modules;
        for (size_t i = 1; i < numServices; ++i)
        {
            if (!services[i]->sharedService)
                SPI_THROW_RUNTIME_ERROR("Second and subsequent services must be shared services");
            if (services[i]->ns != services[0]->ns)
                SPI_THROW_RUNTIME_ERROR("Services must have the same namespace");

            const std::vector<ModuleConstSP>& modules_i = services[i]->modules;
            modules.insert(modules.end(), modules_i.begin(), modules_i.end());
        }

        const std::vector<std::string>& moduleSummaries = Module::combineSummaries(modules, sort);
        summary.insert(summary.end(), moduleSummaries.begin(), moduleSummaries.end());
        return summary;
    }

    /**
     * Returns a sorted list of enumerated type names.
     */
    extern string[] getEnums() const
    {
        self->buildIndexEnums();
        std::vector<std::string> names;
        std::map<std::string, EnumConstSP>::const_iterator iter;
        for (iter = self->indexEnums.begin(); iter != self->indexEnums.end();
             ++iter)
        {
            names.push_back(iter->first);
        }
        return names;
    }

    /**
     * Get an individual Enum by name.
     */
    extern Enum getEnum(string name) const
    {
        self->buildIndexEnums();
        std::map<std::string, EnumConstSP>::const_iterator iter;
        iter = self->indexEnums.find(name);
        if (iter == self->indexEnums.end())
            throw spi::RuntimeError("Cannot find enum '%s'", name.c_str());
        return iter->second;
    }

    /**
     * Returns the enumerands for a given enumerated type.
     */
    extern string[] getEnumerands(string name) const
    {
        self->buildIndexEnums();

        std::map<std::string, EnumConstSP>::const_iterator iter
            = self->indexEnums.find(name);

        if (iter == self->indexEnums.end())
            throw spi::RuntimeError("%s is not an enumerated type",
                                    name.c_str());

        std::vector<std::string> enumerands;
        for(size_t i = 0; i < iter->second->enumerands.size(); ++i)
            enumerands.push_back(iter->second->enumerands[i]->code);

        return enumerands;
    }

    /**
     * Returns a sorted list of class names.
     */
    extern string[] getClasses() const
    {
        self->buildIndexClasses();
        std::vector<std::string> names;
        std::map<std::string, ClassConstSP>::const_iterator iter;
        for (iter = self->indexClasses.begin();
             iter != self->indexClasses.end(); ++iter)
        {
            names.push_back(iter->first);
        }
        return names;
    }

    /**
     * Returns the class details for a class name.
     */
    extern Class getClass(string className) const
    {
        self->buildIndexClasses();
        std::map<std::string, ClassConstSP>::const_iterator iter;
        iter = self->indexClasses.find(className);
        if (iter == self->indexClasses.end())
            throw spi::RuntimeError("Cannot find class '%s'",
                className.c_str());
        return iter->second;
    }

    /**
     * Returns whether a given class is a sub-class of the data type of the given name.
     * Needs to be a method on the Service since otherwise we cannot find base class.
     */
    extern bool isSubClass(Class cls, string name)
    {
        self->buildIndexClasses(); // this includes imported base classes

        if (cls->getName() == name)
            return true; // trivially the case

        std::string baseClassName = cls->baseClassName;
        while (!baseClassName.empty())
        {
            ClassConstSP c = self->getClass(baseClassName);
            if (c->getName() == name)
                return true;
            baseClassName = c->baseClassName;
        }
        return false;
    }

    /**
     * Returns the name of the class for which the given fieldName is a property.
     * If no such class exists then returns an empty string.
     */
    extern string getPropertyClass(string baseClassName, string fieldName) const
    {
        if (baseClassName.empty())
            return std::string();
 
        ClassConstSP baseClass = self->getClass(baseClassName);
        
        const std::vector<ClassAttributeConstSP>& properties = baseClass->properties;
        size_t N = properties.size();
        for (size_t i = 0; i < N; ++i)
        {
            if (properties[i]->name == fieldName)
                return baseClassName;
        }

        if (baseClass->baseClassName.empty())
            return std::string();

        return self->getPropertyClass(baseClass->baseClassName, fieldName);
    }

    /**
    * Returns a sorted list of constructs defined by the service.
    */
    extern string[] getConstructs() const
    {
        self->buildIndexConstructs();
        std::vector<std::string> names;
        for (auto iter = self->indexConstructs.begin(); iter != self->indexConstructs.end(); ++iter)
            names.push_back(iter->first);
        return names;
    }

    /**
     * Returns the construct details for a name.
    */
    extern Construct getConstruct(string name) const
    {
        self->buildIndexConstructs();
        auto iter = self->indexConstructs.find(name);
        if (iter == self->indexConstructs.end())
            SPI_THROW_RUNTIME_ERROR("'" << name << "' not found");
        return iter->second;
    }

private:
    friend class Service_Helper;

    mutable std::map<std::string, EnumConstSP> indexEnums;
    mutable std::map<std::string, ClassConstSP> indexClasses;
    mutable std::map<std::string, ConstructConstSP> indexConstructs;
    void buildIndexEnums() const;
    void buildIndexClasses() const;
    void buildIndexConstructs() const;

};

{
void Service::buildIndexEnums() const
{
    if (indexEnums.empty())
    {
        size_t N = modules.size();
        for (size_t i = 0; i < N; ++i)
        {
            const ModuleConstSP& module = modules[i];
            for (size_t j = 0; j < module->constructs.size(); ++j)
            {
                const ConstructConstSP& construct = module->constructs[j];
                if (construct->getType() == "ENUM")
                {
                    EnumConstSP type = Enum::Coerce(construct);
                    if (type)
                        indexEnums[type->name] = type;
                }
            }
        }
        N = importedEnums.size();
        for (size_t i = 0; i < N; ++i)
        {
            indexEnums[importedEnums[i]->name] = importedEnums[i];
        }
    }
}

void Service::buildIndexClasses() const
{
    if (indexClasses.empty())
    {
        for (size_t i = 0; i < importedBaseClasses.size(); ++i)
        {
            ClassConstSP cls = importedBaseClasses[i];
            indexClasses[cls->dataType->name] = cls;
        }
        for (size_t i = 0; i < modules.size(); ++i)
        {
            const ModuleConstSP& module = modules[i];
            for (size_t j = 0; j < module->constructs.size(); ++j)
            {
                const ConstructConstSP& construct = module->constructs[j];
                if (construct->getType() == "CLASS")
                {
                    ClassConstSP cls = Class::Coerce(construct);
                    if (cls)
                        // dataType->name includes the namespace
                        indexClasses[cls->dataType->name] = cls;
                }
            }
        }
    }
}

void Service::buildIndexConstructs() const
{
    if (indexConstructs.empty())
    {
        for (const ModuleConstSP& module : modules)
        {
            const std::string& ns = module->ns;
            for (const ConstructConstSP& construct : module->constructs)
            {
                // this test is a way of ignoring noDoc SIMPLE_TYPEs
                if (construct->Summary().size() == 0)
                    continue;

                const std::string& name = construct->getName();
                if (ns.empty())
                {
                    indexConstructs.insert({ name, construct });
                }
                else
                {
                    indexConstructs.insert({ ns + "." + name, construct });
                }
            }
        }
    }
}

}
