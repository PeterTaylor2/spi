/* -*-c++-*- */

/*

    Sartorial Programming Interface (SPI) code generators
    Copyright (C) 2012-2023 Sartorial Programming Ltd.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

*/
/**
 * configuration file for structures containing the documentation of a service
 *
 * this is created by the c++ generator and is designed to be sufficient
 * for all other generators
 *
 * implementation details of classes and functions are omitted, but we
 * keep description, all constructs etc.
 *
 * for each generator, there should be something that can generate the
 * code (or documentation) for each data type detected in the service
 */

%module configTypes;

#include <sstream>

/**
 * Defines a data type.
 *
 * This involves things such as the internal name, plus information on how
 * the type is declared and passed as an input to a function call etc.
 */
struct DataType
{
    // currently no point in describing each field since the description
    // does not appear in the generated header files and there is no user
    // guide for spdoc
    string name;
    bool passByReference;
    string refTypeName;
    string valueTypeName;
    PublicType publicType;
    bool noDoc;
    string nsService = "";
    bool objectAsValue = False canHide = True;

    /** Returns the value type (includes the namespace) */
    extern string ValueType()
    {
        if (self->nsService.empty())
            return self->valueTypeName;

        std::ostringstream oss;
        oss << self->nsService << "::" << self->valueTypeName;
        return oss.str();
    }

    /** Returns the reference type (includes the namespace) */
    extern string RefType()
    {
        if (self->nsService.empty())
            return self->refTypeName;

        std::ostringstream oss;
        if (self->valueTypeName == self->refTypeName)
        {
            oss << self->nsService << "::" << self->refTypeName;
        }
        else
        {
            // the assumption is that refTypeName = "const valueTypeName&"
            oss << "const " << self->nsService << "::" 
                << self->valueTypeName << "&";
        }
        return oss.str();
    }

};

/**
 * Defines an attribute which is an input to a function call or output
 * from a function call.
 */
struct Attribute noId=True
{
    // perhaps we should rename attribute as Arg
    string name;
    string[] description;
    DataType dataType;
    int arrayDim;
    bool isOptional;
    Constant defaultValue?;

    property bool isArray
    {
        return arrayDim > 0;
    }

    extern string encoding(bool isOutput = False)
    {
        std::ostringstream oss;
        oss << self->dataType->name << " ";
        if (isOutput)
            oss << "&";
        oss << self->name;
        if (self->isOptional)
            oss << "?";
        for (int i = 0; i < self->arrayDim; ++i)
            oss << "[]";
        return oss.str();
    }  
}
{
    SPI_PRE_CONDITION(arrayDim >= 0 && arrayDim <= 2);
}

/**
 * Defines an attribute of a class.
 */
struct ClassAttribute noId=True
{
    string name;
    string[] description;
    DataType dataType;
    int arrayDim;
    bool isOptional;
    Constant defaultValue?;
    bool accessible;
    string accessor;

    operator Attribute()
    {
        return Attribute::Make(name, description, dataType, arrayDim, isOptional, defaultValue);
    }

    property bool isArray
    {
        return arrayDim > 0;
    }

    property string encoding
    {
        if (!accessible)
            return std::string();
        std::ostringstream oss;
        oss << dataType->name << " " << name;
        if (isOptional)
            oss << "?";
        for (int i = 0; i < arrayDim; ++i)
            oss << "[]";
        return oss.str();
    }
}
{
    SPI_PRE_CONDITION(arrayDim >= 0 && arrayDim <= 2);
}

/**
 * Defines a construct - this is something that is defined by a module
 * and can be either some sort of type definition or function.
 */
struct virtual Construct noId=True
{
    /**
     * Returns the type of the Construct - specific to each sub-class of
     * Construct.
     *
     * Inside the module we keep a list of constructs in the order that
     * they were defined, but we will often need to know what type of
     * Construct object we have in order to decide what to do with it!
     */
    virtual string getType() const;

    /**
     * Returns a short summary of the construct (disregarding description)
     *
     * If the construct is undocumented then this will be a zero size array
     */
    virtual string[] Summary() const;

public:
    virtual std::string getName() const = 0;
};

/**
 * Defines a simple type.
 */
struct SimpleType : Construct
{
    string name;
    string[] description;
    string typeName;
    bool noDoc;

    /**
     * Returns "SIMPLE_TYPE"
     */
    extern string getType() const
    {
        return "SIMPLE_TYPE";
    }

    extern string[] Summary() const
    {
        std::vector<std::string> summary;
        if (!self->noDoc)
        {
            std::ostringstream oss;
            oss << "typedef " << self->typeName << " " << self->name << ";";
            summary.push_back(oss.str());
        }
        return summary;
    }

public:
    std::string getName() const { return name; } 
};

/**
 * Defines a function.
 */
struct Function : Construct
{
    string name;
    string[] description;
    string[] returnTypeDescription;
    DataType returnType;
    int returnArrayDim;
    Attribute[] inputs;
    Attribute[] outputs;
    string[] excelOptions;

    /**
     * Does this Function return an object or not?
     */
    extern bool returnsObject() const
    {
        if (self->objectCount() > 0)
            return true;
        return false;
    }

    /**
     * How many objects does this function return?
     */
    extern int objectCount() const
    {
        if (self->returnType)
        {
            PublicType publicType = self->returnType->publicType;
            if (publicType == PublicType::CLASS ||
                publicType == PublicType::OBJECT ||
                publicType == PublicType::MAP)
            {
                if (self->returnType->objectAsValue)
                    return 0;
                return 1;
            }
            return 0;
        }
        int objectCount = 0;
        for (size_t i = 0; i < self->outputs.size(); ++i)
        {
            PublicType publicType = self->outputs[i]->dataType->publicType;
            if (publicType == PublicType::CLASS ||
                publicType == PublicType::OBJECT ||
                publicType == PublicType::MAP)
            {
                if (!self->outputs[i]->dataType->objectAsValue)
                    ++objectCount;
            }
        }
        return objectCount;
    }

    extern string[] Summary() const
    {
        std::vector<std::string> summary;
        std::ostringstream oss;
        if (self->returnType)
        {
            oss << self->returnType->name;
            for (int i = 0; i < self->returnArrayDim; ++i)
                oss << "[]";   
        }
        else
        {
            oss << "void";
        }
        oss << " " << self->name << "(";
        if (self->inputs.size() == 0 && self->outputs.size() == 0)
        {
            oss << ");";
            summary.push_back(oss.str());
        }
        else
        {
            summary.push_back(oss.str());
            std::vector<std::string> args;
            for (size_t i = 0; i < self->inputs.size(); ++i)
                args.push_back(self->inputs[i]->encoding(false));
            for (size_t i = 0; i < self->outputs.size(); ++i)
                args.push_back(self->outputs[i]->encoding(true));
            size_t numArgs = args.size();
            for (size_t i = 0; i < numArgs; ++i)
            {
                std::ostringstream oss;
                oss << "    " << args[i];
                if ((i+1) == numArgs)
                {
                    oss << ");";
                }
                else
                {
                    oss << ",";
                }
                summary.push_back(oss.str());
            }
        }
        return summary;
    }

    /**
     * Returns "FUNCTION"
     */
    extern string getType() const
    {
        return "FUNCTION";
    }

public:
    std::string getName() const { return name; } 
};

/**
 * Defines an enumerand.
 */
struct Enumerand noId=True
{
    string code;
    string[] strings;
    string[] description;
};

/**
 * Defines an enumerated type.
 */
struct Enum : Construct
{
    string name;
    string[] description;
    Enumerand[] enumerands;

    /**
     * Returns "ENUM"
     */
    extern string getType() const
    {
        return "ENUM";
    }

    extern string[] Summary() const
    {
        std::vector<std::string> summary;

        size_t numEnumerands = self->enumerands.size();
        
        if (numEnumerands > 0)
        {
            std::ostringstream oss;
            oss << "enum " << self->name;
            summary.push_back(oss.str());
            summary.push_back("{");
            for (size_t i = 0; i < numEnumerands; ++i)
            {
                std::ostringstream oss;
                oss << "    " << self->enumerands[i]->code;
                if ((i+1) < numEnumerands)
                    oss << ",";
                summary.push_back(oss.str());
            }
            summary.push_back("};");
        }
        else
        {
            std::ostringstream oss;
            oss << "enum " << self->name << ";";
            summary.push_back(oss.str());
        }

        return summary;
    }

public:
    std::string getName() const { return name; } 
};

/**
 * Defines a class method.
 */
struct ClassMethod noId=True
{
    Function function;
    bool isConst;
    bool isVirtual;
    bool isStatic;
    bool isImplementation;
    string implements = "" canHide=True;

    extern string[] Summary() const
    {
        std::vector<std::string> summary;
        std::vector<std::string> funcSummary = self->function->Summary();

        size_t numLines = funcSummary.size();
        if (numLines == 0)
            return summary;
        summary.reserve(numLines);

        std::ostringstream oss;
        oss << "    ";
        if (self->isVirtual)
            oss << "virtual ";
        if (self->isStatic)
            oss << "static ";

        if (self->isConst)
        {
            std::string lastLine = spi_util::StringReplace(funcSummary[numLines-1], ";", " const;");
            funcSummary[numLines-1] = lastLine;
        }
        oss << funcSummary[0];
        summary.push_back(oss.str());

        for (size_t i = 1; i < numLines; ++i)
        {
            std::ostringstream oss;
            oss << "    " << funcSummary[i];
            summary.push_back(oss.str());
        }

        return summary;
    }
};

/**
 * Defines a CoerceFrom constructor for creating a class by coercion
 * from a single input of some other type.
 */
struct CoerceFrom noId=True
{
    string[] description;
    Attribute coerceFrom;

    extern string[] Summary() const
    {
        std::string encoding = self->coerceFrom->encoding(false);
        std::vector<std::string> summary;
        std::ostringstream oss;
        oss << "    static Coerce(" << encoding << ");";
        summary.push_back(oss.str());
        return summary;
    }
};
 
/**
 * Defines a CoerceTo operator for creating a class by coercion
 * to a class from an instance of another class.
 */
struct CoerceTo noId=True
{
    string[] description;
    string className;
    DataType classType;

    extern string[] Summary() const
    {
        std::vector<std::string> summary;
        std::ostringstream oss;
        oss << "    operator " << self->className << "();";
        summary.push_back(oss.str());
        return summary;
    }
};

/**
 * Defines a class.
 */
struct Class : Construct
{
    string name;
    string ns = "" canHide=True;
    string[] description;
    // as currently stands we cannot forward declare
    // hence we cannot define the baseClassName as a Class
    string baseClassName;
    ClassAttribute[] attributes;
    ClassAttribute[] properties;
    ClassMethod[] methods;
    CoerceFrom[] coerceFrom;
    CoerceTo[] coerceTo;
    bool isAbstract;
    bool noMake;
    string objectName;
    DataType dataType;
    bool isDelegate;
    bool canPut;
    bool hasDynamicAttributes;
    bool asValue = False canHide=True;
    string xlFuncName = "" canHide = True;

    extern string[] Summary() const
    {
        std::vector<std::string> summary;
        std::ostringstream oss;
        oss << "class " << self->name;
        if (!self->baseClassName.empty())
            oss << " : " << self->baseClassName;
        summary.push_back(oss.str());
        summary.push_back("{");

        bool started = false;
        for (size_t i = 0; i < self->attributes.size(); ++i)
        {
            std::ostringstream oss;
            std::string encoding = self->attributes[i]->encoding();
            if (!encoding.empty())
            {
                oss << "    " << encoding << ";";
                summary.push_back(oss.str());
                started = true;
            }
        }
        for (size_t i = 0; i < self->properties.size(); ++i)
        {
            std::ostringstream oss;
            std::string encoding = self->properties[i]->encoding();
            if (!encoding.empty())
            {
                oss << "    property " << encoding << ";";
                summary.push_back(oss.str());
                started = true;
            }
        }
        for (size_t i = 0; i < self->methods.size(); ++i)
        {
            std::vector<std::string> mSummary = self->methods[i]->Summary();
            if (started)
                summary.push_back("");
            else
                started = true;
            for (size_t j = 0; j < mSummary.size(); ++j)
                summary.push_back(mSummary[j]);
        }
        for (size_t i = 0; i < self->coerceFrom.size(); ++i)
        {
            std::vector<std::string> cfSummary = self->coerceFrom[i]->Summary();
            if (started)
                summary.push_back("");
            else
                started = true;
            summary.insert(summary.end(), cfSummary.begin(), cfSummary.end());
        }
        for (size_t i = 0; i < self->coerceTo.size(); ++i)
        {
            std::vector<std::string> ctSummary = self->coerceTo[i]->Summary();
            if (started)
                summary.push_back("");
            else
                started = true;
            summary.insert(summary.end(), ctSummary.begin(), ctSummary.end());
        }
        summary.push_back("};");

        return summary;
    }


    /**
     * Returns "CLASS"
     */
    extern string getType() const
    {
        return "CLASS";
    }

    /**
     * Returns the object name. If objectName is defined, then that is the
     * object name. Otherwise name is the object name.
     */
    extern string ObjectName() const
    {
        if (self->objectName.empty())
            return self->name;
        return self->objectName;
    }

    extern string ServiceNamespace() const
    {
        if (!self->dataType)
            throw spi::RuntimeError("No data type for class %s",
                self->name.c_str());
        return self->dataType->nsService;
    }

public:
    std::string getName() const { return name; } 
};

/**
 * Defines a module.
 */
struct Module noId=True
{
    string name;
    string[] description;
    string ns;
    Construct[] constructs;

    static string[] combineSummaries(Module[] modules, bool sort)
    {
        std::vector<std::string> summary;
        size_t numModules = modules.size();
        std::map<std::string, std::vector<std::string> > nameIndex;
        for (size_t i = 0; i < numModules; ++i)
        {
            ModuleConstSP m = modules[i];
            size_t numConstructs = m->constructs.size();
            for (size_t j = 0; j < numConstructs; ++j)
            {
                const ConstructConstSP& c = m->constructs[j];
                std::vector<std::string> cSummary = c->Summary();
                if (cSummary.size() > 0)
                {
                    if (sort)
                    {
                        nameIndex[c->getName()] = cSummary;
                    }
                    else
                    {
                        summary.push_back("");
                        summary.insert(summary.end(), cSummary.begin(), cSummary.end());
                    }
                }
            }
        }
        if (sort)
        {
            for (std::map<std::string, std::vector<std::string> >::const_iterator iter = nameIndex.begin();
                 iter != nameIndex.end(); ++iter)
            {
                summary.push_back("");
                summary.insert(summary.end(), iter->second.begin(), iter->second.end());
            }
        }
        return summary;
    }
};

/**
 * Defines a service.
 */
struct Service noId=True
{
    string name;
    string[] description;
    string longName;
    string ns;
    string declSpec;
    string version;
    Module[] modules;
    Class[] importedBaseClasses;
    Enum[] importedEnums;
    /** Indicates that this service is shared with a previously defined service.
        As a result we will not implement some of the common service functions for the add-ins. */
    bool sharedService = False canHide=True;

    extern string[] Summary(bool sort) const
    {
        std::vector<std::string> summary;
        size_t numModules = self->modules.size();
        std::ostringstream oss;
        oss << self->name << " namespace = " << self->ns << " version = " << self->version << ";";
        summary.push_back(oss.str());
        const std::vector<std::string>& moduleSummaries = Module::combineSummaries(self->modules, sort);
        summary.insert(summary.end(), moduleSummaries.begin(), moduleSummaries.end());
        return summary;
    }

    static string[] combineSummaries(Service[] services, bool sort)
    {
        SPI_PRE_CONDITION(services.size() > 0);

        size_t numServices = services.size();
        if (numServices == 1)
            return services[0]->Summary(sort);

        SPI_PRE_CONDITION(!services[0]->sharedService);

        std::vector<std::string> summary;
        std::ostringstream oss;
        oss << services[0]->name << " namespace = " << services[0]->ns << " version = " << services[0]->version << ";";
        summary.push_back(oss.str());

        std::vector<ModuleConstSP> modules = services[0]->modules;
        for (size_t i = 1; i < numServices; ++i)
        {
            if (!services[i]->sharedService)
                SPI_THROW_RUNTIME_ERROR("Second and subsequent services must be shared services");
            if (services[i]->ns != services[0]->ns)
                SPI_THROW_RUNTIME_ERROR("Services must have the same namespace");

            const std::vector<ModuleConstSP>& modules_i = services[i]->modules;
            modules.insert(modules.end(), modules_i.begin(), modules_i.end());
        }

        const std::vector<std::string>& moduleSummaries = Module::combineSummaries(modules, sort);
        summary.insert(summary.end(), moduleSummaries.begin(), moduleSummaries.end());
        return summary;
    }

    /**
     * Returns a sorted list of enumerated type names.
     */
    extern string[] getEnums() const
    {
        self->buildIndexEnums();
        std::vector<std::string> names;
        std::map<std::string, EnumConstSP>::const_iterator iter;
        for (iter = self->indexEnums.begin(); iter != self->indexEnums.end();
             ++iter)
        {
            names.push_back(iter->first);
        }
        return names;
    }

    /**
     * Get an individual Enum by name.
     */
    extern Enum getEnum(string name) const
    {
        self->buildIndexEnums();
        std::map<std::string, EnumConstSP>::const_iterator iter;
        iter = self->indexEnums.find(name);
        if (iter == self->indexEnums.end())
            throw spi::RuntimeError("Cannot find enum '%s'", name.c_str());
        return iter->second;
    }

    /**
     * Returns the enumerands for a given enumerated type.
     */
    extern string[] getEnumerands(string name) const
    {
        self->buildIndexEnums();

        std::map<std::string, EnumConstSP>::const_iterator iter
            = self->indexEnums.find(name);

        if (iter == self->indexEnums.end())
            throw spi::RuntimeError("%s is not an enumerated type",
                                    name.c_str());

        std::vector<std::string> enumerands;
        for(size_t i = 0; i < iter->second->enumerands.size(); ++i)
            enumerands.push_back(iter->second->enumerands[i]->code);

        return enumerands;
    }

    /**
     * Returns a sorted list of class names.
     */
    extern string[] getClasses() const
    {
        self->buildIndexClasses();
        std::vector<std::string> names;
        std::map<std::string, ClassConstSP>::const_iterator iter;
        for (iter = self->indexClasses.begin();
             iter != self->indexClasses.end(); ++iter)
        {
            names.push_back(iter->first);
        }
        return names;
    }

    /**
     * Returns the class details for a class name.
     */
    extern Class getClass(string className) const
    {
        self->buildIndexClasses();
        std::map<std::string, ClassConstSP>::const_iterator iter;
        iter = self->indexClasses.find(className);
        if (iter == self->indexClasses.end())
            throw spi::RuntimeError("Cannot find class '%s'",
                className.c_str());
        return iter->second;
    }

    /**
     * Returns the name of the class for which the given fieldName is a property.
     * If no such class exists then returns an empty string.
     */
    extern string getPropertyClass(string baseClassName, string fieldName) const
    {
        if (baseClassName.empty())
            return std::string();
 
        ClassConstSP baseClass = self->getClass(baseClassName);
        
        const std::vector<ClassAttributeConstSP>& properties = baseClass->properties;
        size_t N = properties.size();
        for (size_t i = 0; i < N; ++i)
        {
            if (properties[i]->name == fieldName)
                return baseClassName;
        }

        if (baseClass->baseClassName.empty())
            return std::string();

        return self->getPropertyClass(baseClass->baseClassName, fieldName);
    }

private:
    friend class Service_Helper;

    mutable std::map<std::string, EnumConstSP> indexEnums;
    mutable std::map<std::string, ClassConstSP> indexClasses;
    void buildIndexEnums() const;
    void buildIndexClasses() const;

};

{
void Service::buildIndexEnums() const
{
    if (indexEnums.empty())
    {
        size_t N = modules.size();
        for (size_t i = 0; i < N; ++i)
        {
            const ModuleConstSP& module = modules[i];
            for (size_t j = 0; j < module->constructs.size(); ++j)
            {
                const ConstructConstSP& construct = module->constructs[j];
                if (construct->getType() == "ENUM")
                {
                    EnumConstSP type = Enum::Coerce(construct);
                    if (type)
                        indexEnums[type->name] = type;
                }
            }
        }
        N = importedEnums.size();
        for (size_t i = 0; i < N; ++i)
        {
            indexEnums[importedEnums[i]->name] = importedEnums[i];
        }
    }
}

void Service::buildIndexClasses() const
{
    if (indexClasses.empty())
    {
        for (size_t i = 0; i < importedBaseClasses.size(); ++i)
        {
            ClassConstSP cls = importedBaseClasses[i];
            indexClasses[cls->dataType->name] = cls;
        }
        for (size_t i = 0; i < modules.size(); ++i)
        {
            const ModuleConstSP& module = modules[i];
            for (size_t j = 0; j < module->constructs.size(); ++j)
            {
                const ConstructConstSP& construct = module->constructs[j];
                if (construct->getType() == "CLASS")
                {
                    ClassConstSP cls = Class::Coerce(construct);
                    if (cls)
                        // dataType->name includes the namespace
                        indexClasses[cls->dataType->name] = cls;
                }
            }
        }
    }
}
}
