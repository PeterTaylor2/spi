/* -*-c++-*- */

/*

    Sartorial Programming Interface (SPI) code generators
    Copyright (C) 2012-2023 Sartorial Programming Ltd.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

*/
/**
 * defines the PublicType enumerated type
 */

%module publicType;

/**
 * The public type describes the type of data from the end-user perspective.
 *
 * There are the primitive types, and two generic types ENUM and OBJECT.
 * At present ENUM is seen as STRING with no further information available,
 * but this will change in the future.
 */
enum PublicType
{
    /**
     * Bool type - can take the values true or false.
     */
    BOOL,
    /**
     * Single character - ideally should be a printable character.
     */
    CHAR,
    /**
     * Integer - standard 32-bit integer. This should be large enough for
     * most purposes - the maximum number is over one billion.
     */
    INT,
    /**
     * Floating point with double precision.
     */
    DOUBLE,
    /**
     * String - represented as the c++ std::string class.
     */
    STRING,
    /**
     * Date - represented externally by the spi::Date class which supports
     * the standard calendar.
     */
    DATE,
    /**
     * DateTime - represented externally by the spi::DateTime class which
     * supports the standard calendar + time (without timezone information)
     */
    DATETIME,
    /**
     * Any enumerated type. Representally externally via its string
     * equivalent.
     */
    ENUM,
    /**
     * An object of a specific class.
     */
    CLASS,
    /**
     * A generic object.
     */
    OBJECT,
    /**
     * A map object which simply consists of name/value pairs.
     */
    MAP,
    /**
     * A variant - any of the above with late binding.
     */
    VARIANT

};

/**
 * Given a c++ typename, this function will verify that this is a valid
 * primitive type, and return the corresponding PublicType value.
 *
 * Not all public types are primitive types, but all primitive types have
 * a corresponding public type.
 */
extern PublicType verifyPrimitiveTypeName(
    /**
     * This is the name of the c++ data type that we are intending to
     * verify.
     *
     *!The following types are understood by this function:
     *!\begin{enumerate}
     *!   \item bool
     *!   \item char
     *!   \item int
     *!   \item double
     *!   \item std::string
     *!   \item spi::Date
     *!   \item spi::DateTime
     *!   \item spi::Variant
     *!\end{enumerate}
     */
    string typeName)
{
    static std::map<std::string, PublicType::Enum> goodTypes;

    if (goodTypes.empty())
    {
        goodTypes["bool"] = PublicType::BOOL;
        goodTypes["char"] = PublicType::CHAR;
        goodTypes["int"] = PublicType::INT;
        goodTypes["double"] = PublicType::DOUBLE;
        goodTypes["std::string&"] = PublicType::STRING;
        goodTypes["spi::Date"] = PublicType::DATE;
        goodTypes["spi::DateTime"] = PublicType::DATETIME;
        goodTypes["spi::ObjectConstSP&"] = PublicType::OBJECT;
        goodTypes["spi::Variant&"] = PublicType::VARIANT;
        goodTypes["spi::MapObjectSP&"] = PublicType::MAP;
    }

    std::map<std::string, PublicType::Enum>::iterator iter =
        goodTypes.find(typeName);

    if (iter == goodTypes.end())
    {
        throw spi::RuntimeError("%s is not a valid primitive type name",
                                typeName.c_str());
    }
    return iter->second;
}
