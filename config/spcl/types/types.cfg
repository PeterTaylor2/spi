/* -*-c++-*- */

/*

    Sartorial Programming Interface (SPI) code generators
    Copyright (C) 2012-2023 Sartorial Programming Ltd.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

*/

%module types;

#include "attribute.hpp"
#include "cppType.hpp"
#include "dataType.hpp"
#include "struct.hpp"
#include "innerClass.hpp"
#include "wrapperClass.hpp"
#include "serviceDefinition.hpp"
#include "verbatim.hpp"
#include "inputConverter.hpp"
#include "converter.hpp"
#include "enum.hpp"

enum PublicType <spdoc::PublicType::Enum>
    innerHeader="<spi/spdoc_publicType.hpp>"
{
    BOOL = spdoc::PublicType::BOOL,
    CHAR = spdoc::PublicType::CHAR,
    INT = spdoc::PublicType::INT,
    DOUBLE = spdoc::PublicType::DOUBLE,
    STRING = spdoc::PublicType::STRING,
    DATE = spdoc::PublicType::DATE,
    DATETIME = spdoc::PublicType::DATETIME,
    ENUM = spdoc::PublicType::ENUM,
    CLASS = spdoc::PublicType::CLASS,
    OBJECT = spdoc::PublicType::OBJECT,
    MAP = spdoc::PublicType::MAP,
    VARIANT = spdoc::PublicType::VARIANT
};

class virtual InputConverter<open shared const InputConverter>
{
    InputConverter(string format)
    {
        return InputConverterStringFormat::Make(format);
    }
};

class InputConverterStringFormat<open shared const InputConverterStringFormat> : InputConverter
{
    public string format{ return self->format(); }

    as_value()
    {
        return spi::Value(format());
    }
}
{
    return ::InputConverterStringFormat::Make(format);
}


class InputConverterClass<open shared const InputConverterClass> : InputConverter
{
    public string format{ return self->format(); }
}
{
    return ::InputConverterClass::Make(format);
}


class DataType <open shared const DataType>
{
    private string name
    {
        return self->name();
    }

    private string nsService = "" canHide=True
    {
        return self->nsService();
    }

    private string cppName
    {
        return self->cppName();
    }

    private string outerType
    {
        return self->outerType();
    }

    private string innerType = "" canHide=True
    {
        return self->innerType();
    }

    private string innerRefType = "" canHide=True
    {
        return self->innerRefType();
    }

    private PublicType publicType
    {
        return self->publicType();
    }

    private string objectName = "" canHide=True
    {
        return self->objectName();
    }

    private bool isClosed
    {
        return self->isClosed();
    }

    private bool noDoc
    {
        return self->noDoc();
    }

    private InputConverter convertIn? canHide=True
    {
        return self->convertIn();
    }

    private string convertOut = "" canHide=True
    {
        return self->convertOut();
    }

    private string copyInner = "" canHide=True
    {
        return self->copyInner();
    }

    private bool ignored = False canHide=True
    {
        return self->ignored();
    }
}
{
    // we don't need to split name since ::DataType::Make simply joins
    // them back together
    ::DataTypeConstSP self = ::DataType::Make(
        name, "", nsService, cppName, outerType, innerType, innerRefType, publicType, 
        objectName, isClosed, noDoc, convertIn, convertOut, copyInner,
        ::DataTypeConstSP(), false, false, ignored);

    return self;
}

// we only need Attribute for class properties
// i.e. output only
// so we only care about dataType, name, arrayDim
class Attribute <open shared const Attribute>
{
    private DataType dataType
    {
        return self->dataType();
    }

    private string name
    {
        return self->name();
    }

    private int arrayDim = 0 canHide=True
    {
        return self->arrayDim();
    }
}
{
    ::AttributeConstSP self = ::Attribute::Make(
        std::vector<std::string>(),
        dataType,
        name,
        arrayDim);

    return self;
}

class ClassProperty <open shared const ClassAttribute>
{
    private Attribute attribute{ return self->attribute(); }
}
{
    return ::ClassAttribute::Make(attribute,
        ::ClassAttributeAccess::PROPERTY,
        ::VerbatimConstSP(),
        false,
        false,
        std::string(),
        false,
        ::ConverterConstSP());
}

class Enumerand<open shared const Enumerand> noId=True
{
    public string code
    {
         return self->name();
    }
    public string[] strings
    {
        std::vector<std::string> strings;
        strings.push_back(self->value());
        const std::vector<std::string> alternates = self->alternates();
        for (size_t i = 0; i < alternates.size(); ++i)
            strings.push_back(alternates[i]);
        return strings;
    }
}
{
    std::vector<std::string> description;
    std::string value;
    std::vector<std::string> alternates;
    for (size_t i = 0; i < strings.size(); ++i)
    {
        if (i == 0)
            value = strings[i];
        else
            alternates.push_back(strings[i]);
    }

    return ::Enumerand::Make(description, code, value, alternates);
}

class Enum <open shared const Enum>
{
    public string name
    {
        return self->name();
    }
    public Enumerand[] enumerands
    {
        return self->enumerands();
    }
}
{
    // is there an issue with ns?
    std::vector<std::string> description;
    std::string ns;
    std::string innerName;
    std::string innerHeader;
    std::string enumTypedef;
    return ::Enum::Make(description, name, ns, innerName, innerHeader, enumTypedef, enumerands);
}

class virtual BaseClass <open shared const Class>
{};

class BaseStruct <open shared const Struct> : BaseClass
{
    private string[] description
    {
        return self->description();
    }
    private string name
    {
        return self->name();
    }
    private string ns
    {
        return self->ns();
    }
    private BaseClass baseClass?
    {
        return self->baseClass();
    }
    private bool noMake
    {
        return self->noMake();
    }
    private string objectName=""
    {
        return self->objectName();
    }
    private bool canPut=False
    {
        return self->canPut();
    }
    private bool noId=False
    {
        return self->noId();
    }
    private bool isVirtual=False
    {
        return self->isVirtual();
    }
    private bool asValue=False canHide=True
    {
        return self->asValue();
    }
    private bool uuid=False canHide=True
    {
        return self->uuid();
    }
    private bool byValue=False canHide=True
    {
        return self->byValue();
    }
    private bool useAccessors=False canHide=True
    {
        return self->useAccessors();
    }
    private string funcPrefix = "" canHide=True
    {
        return self->funcPrefix();
    }
    private string instance = "" canHide = True
    {
        return self->instance();
    }
}
{
    ::StructSP self = ::Struct::Make(
        description, name, ns, baseClass, noMake, objectName, canPut, noId, isVirtual, asValue, 
        uuid, byValue, useAccessors, funcPrefix, instance);

    SPI_POST_CONDITION(self->isAbstract());

    return self;
}

class InnerClass <open shared const InnerClass> constructor="INNER_CLASS_MAKE"
{
    private string typeName 
    {
        return self->typeName();
    }
    private string ns 
    {
        return self->ns();
    }
    private string freeFunc 
    {
        return self->freeFunc();
    }
    private string copyFunc 
    {
        return self->copyFunc();
    }
    private string preDeclaration 
    {
        return self->preDeclaration();
    }
    private string sharedPtr 
    {
        return self->sharedPtr();
    }
    private bool   isShared 
    {
        return self->isShared();
    }
    private bool   isConst 
    {
        return self->isConst();
    }
    private bool   isOpen 
    {
        return self->isOpen();
    }
    private bool   isStruct 
    {
        return self->isStruct();
    }
    private bool   isCached 
    {
        return self->isCached();
    }
    private bool   isTemplate 
    {
        return self->isTemplate();
    }
    private bool   byValue 
    {
        return self->byValue();
    }
    private string boolTest = "" canHide=True 
    {
        return self->boolTest();
    }
    private bool   allowConst = false canHide=True 
    {
        return self->allowConst();
    }
}
{
    ::InnerClassConstSP self = ::InnerClass::Make(
        typeName, ns, freeFunc, copyFunc, preDeclaration, sharedPtr,
        isShared, isConst, isOpen, isStruct, isCached, isTemplate, byValue, boolTest, allowConst);
    return self;
}

class BaseWrapperClass <open shared const WrapperClass> : BaseClass
{
    private string[] description 
    {
        return self->description();
    }
    private string name 
    {
        return self->name();
    }
    private string ns 
    {
        return self->ns();
    }
    private InnerClass innerClass 
    {
        return self->innerClass();
    }
    private BaseWrapperClass baseClass? 
    {
        return self->baseClass();
    }
    private bool isVirtual 
    {
        return self->isVirtual();
    }
    private bool noMake 
    {
        return self->noMake();
    }
    private string objectName = "" 
    {
        return self->objectName();
    }
    private bool isDelegate
    {
        return self->isDelegate();
    }
    private bool canPut = False 
    {
        return self->canPut();
    }
    private bool noId = False 
    {
        return self->noId();
    }
    private DataType dataType 
    {
        return self->dataType();
    }
    private bool asValue = False canHide = True 
    {
        return self->asValue();
    }
    private ClassProperty[] classProperties canHide = True 
    {
        return self->classProperties();
    }
    private bool uuid = False canHide=True 
    {
        return self->uuid();
    }
    private string funcPrefix = "" canHide = True
    {
        return self->funcPrefix();
    }
    private string instance = "" canHide = True
    {
        return self->instance();
    }
}
{
    ::WrapperClassSP self = ::WrapperClass::Make(
        description, name, ns, innerClass, baseClass, isVirtual,
        noMake, objectName, isDelegate, canPut, noId, asValue, uuid,
        funcPrefix, instance);

    SPI_POST_CONDITION(self->isAbstract());

    self->setDataType(dataType);

    for (size_t i = 0; i < classProperties.size(); ++i)
        self->addClassAttribute(classProperties[i]);

    return self;
}

class TypesLibrary <open shared const TypesLibrary>
{
    private string name
    {
        return self->name();
    }

    private string ns
    {
        return self->ns();
    }
    
    private string version
    {
        return self->version();
    }

    private string lastModuleName
    {
        return self->lastModuleName();
    }

    private DataType[] dataTypes
    {
        return self->dataTypes();
    }

    private DataType[] publicDataTypes
    {
        return self->publicDataTypes();
    }

    private BaseClass[] baseClasses
    {
        return self->baseClasses();
    }

    private Enum[] enums
    {
        return self->enums();
    }
}
{
    ::TypesLibraryConstSP self = ::TypesLibrary::Make(
        name, ns, version, lastModuleName, dataTypes, publicDataTypes, baseClasses, enums);
    return self;
}

