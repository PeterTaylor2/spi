# Sartorial Programming Interface

The Sartorial Programming Interface (SPI) consists of two main components.

The first component consists of code generators which use configuration files (in a proprietary format defined by SPI)
and creates mostly C++ files (also Python, VBA, C#) which can then be compiled and linked against runtime libraries to
produce shared libraries for use in a variety of different contexts.
The contexts currently supported are Excel, Python, C# and a stylised C++.

The second component are the runtime libraries mentioned above.

The project which wants to use SPI will have a C or C++ library defined in the usual way of such libraries - i.e.
source code, header files, libraries (static or dynamic). There is no particular constraint on the C/C++ libraries.

The process of using SPI is termed as wrapping - you define some extra configuration files which describe how you
want to wrap this library into a C++ shared library that hides the details of the original C/C++ (this is the stylised
C++ context mentioned above). This stylised C++ library supports regular C++ features such as shared pointers,
exception handling, standard templates (mostly string and vector), classes and single inheritance for classes.

It also supports serialization in such a way that objects (instances of classes) can be written to file in such
a form that you can read that file and re-create the object in a separate process.
Furthermore function calls to the C++ library can be logged to give you a record of what functions were used in
that session, and this logfile can be replayed - again in a completely different session.

The log and replay method provides a good way to support the use of the wrapped library. The wrapped library can be used
in some application and a logfile can be created by the application support team. The library support team can
then diagnose reported problems without needing to be able to run the particular application.

Another by-product of the wrapping process is a user guide writen using LaTeX which can then be compiled into PDF
format.

The wrapped C++ library can then be further wrapped to create XLLs for Excel, PYDs for Python and C# code for .NET.

## Licenses

We have licensed the code generators using GPL.
We have licensed the runtime lirary using LGPL.
Any code generated by the code generators is unlicensed - but you can apply your own license if you should so wish.

What this means in practice is that if you want to create a commercial product using SPI then there should be
no problem. The runtime libraries are LGPL so you can include them in your commercial product.

However the code generators are GPL - so in practice you cannot include them in your released product.
But since you are free to do whatever you like with the generated code this should not be a restraint in practice.

## Examples

As a separate project we are developing example products which show SPI in action in a variety of different modes.
These sample products will be based on the open source ISDA/CDS standard library.

For non-commercial use SPI has been used to develop a collection of Bridge functionality (Bridge is a card game).

For commercial use SPI has been used to develop the analytical libraries used by a hedge fund.

## Building the software

The software is built using makefiles - OK - I am admit it is old-fashioned. However these makefiles will work for
Windows, Linux and possibly even for Apple/Mac (it is a long time since I tried to compile on an Apple/Mac).
Visual Studio projects can be generated from the makefiles, and then manually combined into a Visual Studio solution
file. Most of the code over the years has been developed within Visual Studio - currently VS16 (2019) and VS17 (2022)
are fully supported.

In practice when using the software for developing a project, you do not need to compile the code generators for each
developer using the SPI framework. Hence we have a tool for creating a distribution package of SPI which consists of
the source code of the runtime library, plus executables for each code generator. When debugging you do need to be
able to step through the runtime library code, but the final application you build only includes the generated files
and generally you do not need to debug the code generation process.

## Versions of interface languages supported

We support Excel versions 4, 12 and 15, although the Excel4 code has not been tested for a while.
We support 32-bit and 64-bit versions of Excel (although Excel4 is 32-bit only).

We support either Python2 or Python3. Essentially what is needed to build for a particular version of Python are
the header files for that version of Python, and the runtime libraries for Python.

We bundle header files and libraries for the following versions of Python for Windows: 27, 37, 38, 39, 310.
We support both 32-bit and 64-bit versions of Python.
On Linux we have successfully used version 3.9 of Python.

We do not use the ABI-compatible versions of Python for Python3. This is because we need to use the Python datetime
class which does not fall under the ABI-compatible framework (as far as I can tell).

For C# development we build a C-DLL in either 32-bit or 64-bit which can be used by P/INVOKE (platform invoke) by C#
code. The plan would be to deliver the C# code to an application written using C# and allow that application to decide
which framework to use for building the application. Hence we believe there is no particular restriction on the
version for the C# build.

Note that all these platforms can interoperate via the level of the wrapped C++ library. The same C++ shared libraries
are used by each of the interface languages supported.

In practice what has been done in this context is to mix and match the Excel add-ins with the Python extensions via
3rd party applications such as PyXLL.

## Contributions

Contributions would be invited for the following areas:

1. New interface languages, e.g. Java is one language we have considered supporting.
2. Completion of the user guide - it is partly done but needs some extra work.
3. Binary serialisation of objects. Currently there is a native <spi> format and JSON. Binary serialisation should have performance improvements in network applications where all nodes are using the same version of the software.

## History

This product has been developed for nearly 11 years. Previously it was developed under the auspices of the company
Sartorial Programming Ltd. This company is now being closed down - so the decision was made to publish the code
as an open source.

The main developments happened in the years 2012-2014. Subsequently development has been slower but has been
focussed on the development of the analytics library for the hedge fund that I mentioned.
As of 2014 the project was sufficiently complete to allow for the development of some Bridge applications (in addition
to being a software developer I am also a very keen Bridge player who has represented by country at the game).
However the use of the project within a commercial application has shaped the project to get to a point where it
seems to be extremely reliable and covers a number of use cases - many of which were originally not envisioned.

## Contacts

The only developer so far is myself - PeterTaylor2 on github.






